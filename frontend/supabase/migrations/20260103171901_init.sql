-- Generated by Endstorm AppBuilder (Supabase-backed)
-- Apply with Supabase CLI: supabase db reset (local) or paste into Supabase SQL editor.

create extension if not exists pgcrypto;

-- Table: cases
create table if not exists public.cases (
  id uuid primary key default gen_random_uuid(),
  created_at timestamptz not null default now(),
  owner_id uuid not null references auth.users(id) on delete cascade,
  title text not null,
  court text not null,
  decision_date date not null,
  citation text not null,
  summary text,
  full_text text,
  updated_at timestamptz not null default now()
);

create index if not exists cases_owner_id_idx on public.cases(owner_id);

alter table public.cases enable row level security;
drop policy if exists "cases_select_own" on public.cases;
drop policy if exists "cases_insert_own" on public.cases;
drop policy if exists "cases_update_own" on public.cases;
drop policy if exists "cases_delete_own" on public.cases;

create policy "cases_select_own" on public.cases for select using (auth.uid() = owner_id);
create policy "cases_insert_own" on public.cases for insert with check (auth.uid() = owner_id);
create policy "cases_update_own" on public.cases for update using (auth.uid() = owner_id) with check (auth.uid() = owner_id);
create policy "cases_delete_own" on public.cases for delete using (auth.uid() = owner_id);

-- Table: issues
create table if not exists public.issues (
  id uuid primary key default gen_random_uuid(),
  created_at timestamptz not null default now(),
  owner_id uuid not null references auth.users(id) on delete cascade,
  name text not null,
  description text,
  related_case_id text not null,
  updated_at timestamptz not null default now()
);

create index if not exists issues_owner_id_idx on public.issues(owner_id);

alter table public.issues enable row level security;
drop policy if exists "issues_select_own" on public.issues;
drop policy if exists "issues_insert_own" on public.issues;
drop policy if exists "issues_update_own" on public.issues;
drop policy if exists "issues_delete_own" on public.issues;

create policy "issues_select_own" on public.issues for select using (auth.uid() = owner_id);
create policy "issues_insert_own" on public.issues for insert with check (auth.uid() = owner_id);
create policy "issues_update_own" on public.issues for update using (auth.uid() = owner_id) with check (auth.uid() = owner_id);
create policy "issues_delete_own" on public.issues for delete using (auth.uid() = owner_id);

-- Table: citations
create table if not exists public.citations (
  id uuid primary key default gen_random_uuid(),
  created_at timestamptz not null default now(),
  owner_id uuid not null references auth.users(id) on delete cascade,
  case_id text not null,
  cited_case_id text not null,
  context text,
  citation_locked boolean not null,
  updated_at timestamptz not null default now()
);

create index if not exists citations_owner_id_idx on public.citations(owner_id);

alter table public.citations enable row level security;
drop policy if exists "citations_select_own" on public.citations;
drop policy if exists "citations_insert_own" on public.citations;
drop policy if exists "citations_update_own" on public.citations;
drop policy if exists "citations_delete_own" on public.citations;

create policy "citations_select_own" on public.citations for select using (auth.uid() = owner_id);
create policy "citations_insert_own" on public.citations for insert with check (auth.uid() = owner_id);
create policy "citations_update_own" on public.citations for update using (auth.uid() = owner_id) with check (auth.uid() = owner_id);
create policy "citations_delete_own" on public.citations for delete using (auth.uid() = owner_id);
